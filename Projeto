"""
=========================================
API DE DOEN√áA CARD√çACA ü´Ä
=========================================

Autor: Alyson Alves
Descri√ß√£o:
------------
Aplica√ß√£o desenvolvida com FastAPI para prever a probabilidade de uma pessoa
ter doen√ßa card√≠aca, com base em idade, colesterol e tipo de dor no peito (cp).

O modelo foi treinado usando TensorFlow e dados do reposit√≥rio UCI Machine Learning.
Os resultados s√£o armazenados em um banco de dados SQLite e exibidos via interface HTML.

Recursos:
---------
‚úÖ Interface web (HTML + Jinja2)
‚úÖ Banco de dados SQLite para hist√≥rico de pacientes
‚úÖ Modelo simples de aprendizado de m√°quina em TensorFlow
‚úÖ API REST com rota de listagem de pacientes
‚úÖ Inser√ß√£o autom√°tica de dados fict√≠cios (300 pacientes)

Requisitos:
-----------
pip install fastapi uvicorn tensorflow pandas scikit-learn ucimlrepo jinja2

Execu√ß√£o:
---------
uvicorn main:app --reload

Estrutura esperada:
-------------------
üìÇ projeto/
 ‚î£ üìÇ templates/
 ‚îÉ ‚îó üìÑ index.html
 ‚î£ üìÑ main.py
 ‚îó üìÑ data.db (gerado automaticamente)
"""

# ==========================================================
# Importa√ß√µes
# ==========================================================
import random
from pathlib import Path as SysPath
from typing import List, Dict

import sqlite3
import pandas as pd
import tensorflow as tf
from sklearn.preprocessing import StandardScaler
from ucimlrepo import fetch_ucirepo

from fastapi import FastAPI, Request, Form
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates


# ==========================================================
# Configura√ß√µes iniciais
# ==========================================================
app = FastAPI(
    title="API de Doen√ßa Card√≠aca",
    version="1.0.0",
    description="Predi√ß√£o de risco card√≠aco usando TensorFlow e dados da UCI."
)

templates = Jinja2Templates(directory="templates")
DB_PATH = SysPath("data.db")


# ==========================================================
# BANCO DE DADOS
# ==========================================================
def get_connection():
    """
    Cria e retorna uma conex√£o com o banco SQLite.
    """
    conn = sqlite3.connect(DB_PATH, check_same_thread=False)
    conn.row_factory = sqlite3.Row
    return conn


def init_db():
    """
    Inicializa o banco de dados:
    - Cria a tabela 'pacientes' se n√£o existir.
    - Insere 300 registros fict√≠cios caso o banco esteja vazio.
    """
    conn = get_connection()
    cur = conn.cursor()

    # Cria√ß√£o da tabela
    cur.execute("""
        CREATE TABLE IF NOT EXISTS pacientes (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            nome TEXT,
            idade REAL,
            colesterol REAL,
            cp INTEGER,
            probabilidade_doenca REAL
        )
    """)
    conn.commit()

    # Populando com dados fict√≠cios
    cur.execute("SELECT COUNT(*) FROM pacientes")
    count = cur.fetchone()[0]

    if count < 300:
        nomes = [f"Paciente_{i+1}" for i in range(300)]
        for nome in nomes:
            idade = random.randint(30, 80)
            colesterol = random.randint(150, 300)
            cp = random.randint(0, 3)
            probabilidade = round(random.uniform(0, 100), 2)
            cur.execute(
                """
                INSERT INTO pacientes (nome, idade, colesterol, cp, probabilidade_doenca)
                VALUES (?, ?, ?, ?, ?)
                """,
                (nome, idade, colesterol, cp, probabilidade)
            )
        conn.commit()
    conn.close()


# Inicializa o banco ao iniciar o app
init_db()


# ==========================================================
# TREINAMENTO DO MODELO
# ==========================================================
# Carrega dataset da UCI
doenca_cardiaca = fetch_ucirepo(id=45)
X = doenca_cardiaca.data.features[['age', 'chol', 'cp']]
y = (doenca_cardiaca.data.targets > 0) * 1  # Bin√°rio: 0 (sem doen√ßa), 1 (com doen√ßa)

# One-hot encoding para coluna 'cp' (tipo de dor no peito)
df_cp = pd.get_dummies(X['cp'], prefix='cp')
X = X.drop('cp', axis=1).join(df_cp)

# Normaliza√ß√£o das features num√©ricas
scaler = StandardScaler()
X[['age', 'chol']] = scaler.fit_transform(X[['age', 'chol']])

# Cria√ß√£o de um modelo simples de neur√¥nio √∫nico
tf.random.set_seed(31)
quantidade_features = X.shape[1]
pesos = tf.Variable(tf.random.normal([quantidade_features, 1]), name='pesos')
vies = tf.Variable(tf.random.normal([1]), name='vies')


def neuronio(x):
    """Implementa o c√°lculo de um neur√¥nio: y = xW + b"""
    return tf.add(tf.matmul(x, pesos), vies)


# TensorFlow - Treinamento manual
entrada = tf.constant(X, dtype=tf.float32)
y_tensor = tf.constant(y, dtype=tf.float32)
otimizador = tf.optimizers.SGD(learning_rate=0.01)
loss_fn = tf.keras.losses.BinaryCrossentropy()

EPOCHS = 1000
for epoca in range(EPOCHS):
    with tf.GradientTape() as tape:
        pred = tf.sigmoid(neuronio(entrada))
        loss = loss_fn(y_tensor, pred)
    gradientes = tape.gradient(loss, [pesos, vies])
    otimizador.apply_gradients(zip(gradientes, [pesos, vies]))


def prever_doenca(idade: float, colesterol: float, cp: int) -> float:
    """
    Realiza a previs√£o da probabilidade de doen√ßa card√≠aca.
    Retorna a probabilidade em porcentagem.
    """
    colunas_cp = [col for col in X.columns if col.startswith('cp_')]
    cp_dict = {col: 0 for col in colunas_cp}
    cp_dict[f'cp_{cp}'] = 1

    df = pd.DataFrame([[idade, colesterol]], columns=['age', 'chol'])
    df[['age', 'chol']] = scaler.transform(df[['age', 'chol']])
    df = df.join(pd.DataFrame([cp_dict]))
    df = df[X.columns]

    tensor = tf.constant(df.values, dtype=tf.float32)
    prob = tf.sigmoid(neuronio(tensor)).numpy()[0][0]
    return round(prob * 100, 2)


# ==========================================================
# INTERFACE HTML
# ==========================================================
@app.get("/", response_class=HTMLResponse)
def home(request: Request):
    """
    Exibe a p√°gina inicial com o formul√°rio.
    """
    return templates.TemplateResponse("index.html", {"request": request, "resultado": None})


@app.post("/", response_class=HTMLResponse)
def process_form(
    request: Request,
    nome: str = Form(...),
    idade: float = Form(...),
    colesterol: float = Form(...),
    cp: int = Form(...)
):
    """
    Recebe os dados do formul√°rio, faz a previs√£o e grava no banco.
    """
    probabilidade = prever_doenca(idade, colesterol, cp)

    conn = get_connection()
    cur = conn.cursor()
    cur.execute(
        "INSERT INTO pacientes (nome, idade, colesterol, cp, probabilidade_doenca) VALUES (?, ?, ?, ?, ?)",
        (nome, idade, colesterol, cp, probabilidade)
    )
    conn.commit()
    conn.close()

    return templates.TemplateResponse(
        "index.html",
        {"request": request, "resultado": f"{nome}: {probabilidade:.2f}% de chance de doen√ßa card√≠aca"}
    )


# ==========================================================
# API - ENDPOINTS JSON
# ==========================================================
@app.get("/pacientes", summary="Lista todos os pacientes cadastrados")
def listar_pacientes() -> Dict[str, List[Dict]]:
    """
    Retorna todos os pacientes cadastrados no banco de dados.
    """
    conn = get_connection()
    cur = conn.cursor()
    cur.execute("SELECT * FROM pacientes")
    registros = [dict(row) for row in cur.fetchall()]
    conn.close()
    return {"pacientes": registros}
